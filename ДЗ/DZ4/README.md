## Описание

Разработать ассемблер и интерпретатор для учебной виртуальной машины
(УВМ). Система команд УВМ представлена далее.

Для ассемблера необходимо разработать читаемое представление команд
УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к
которой задается из командной строки. Результатом работы ассемблера является
бинарный файл в виде последовательности байт, путь к которому задается из
командной строки. Дополнительный ключ командной строки задает путь к файлу-
логу, в котором хранятся ассемблированные инструкции в духе списков
“ключ=значение”, как в приведенных далее тестах.

Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ
и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон
также указывается из командной строки.

Форматом для файла-лога и файла-результата является **csv**.

Необходимо реализовать приведенные тесты для всех команд, а также
написать и отладить тестовую программу.

### Загрузка константы

| А        | B         |
|----------|-----------|
| Биты 0-4 | Биты 5—21 |
| 30       | Константа |

Размер команды: 3 байт. Операнд: поле B. Результат: регистр-аккумулятор.

    Тест (A=30, B=684):
    0x9E, 0x55, 0x00

### Чтение из памяти

| А        | B         |
|----------|-----------|
| Биты 0—4 | Биты 5—17 |
| 0        | Адрес     |

Размер команды: 3 байт. Операнд: ячейка памяти по адресу, которым
является поле B. Результат: регистр-аккумулятор.

    Тест ((A=0, B=327):
    0xE0, 0x28, 0x00


### Запись в память

| A        | B         |
|----------|-----------|
| Биты 0—4 | Биты 5—17 |
| 8        | Адрес     |

Размер команды: 3 байт. Операнд: регистр-аккумулятор. Результат: ячейка
памяти по адресу, которым является поле B.

    Тест (A=8, B=168):
    0x08, 0x15, 0x00

### Бинарная операция: ">"

| A        | B         |
|----------|-----------|
| Биты 0—4 | Биты 5—17 |
| 20       | Адрес     |

Размер команды: 3 байт. Первый операнд: ячейка памяти по адресу, которым
является поле B. Второй операнд: регистр-аккумулятор. Результат: ячейка памяти
по адресу, которым является поле B.

    Тест (A=20, B=679):
    0xF4, 0x54, 0x00

---

### Тестовая программа
Выполнить поэлементно операцию ">" над вектором длины 6 и числом 67.
Результат записать в новый вектор.

## Клонирование репозитория
```
git clone https://github.com/elinaleonovva/Konfig_leonova.git
cd Konfig_leonova/ДЗ/DZ4
```

## Запуск программ

1. **Для ассемблера**:
   Ассемблер запускается из командной строки с передачей трех аргументов:

   - input.txt — путь к входному файлу с исходным кодом ассемблера.
   - output.bin — путь к выходному файлу, в который будет записан результат ассемблирования в бинарном формате.
   - log.csv — путь к файлу для записи информации об обработанных командах.
   
   Пример запуска:
   ```
   python assembler.py input.txt output.bin log.csv
   ```
   Убедитесь, что все файлы находятся в той же директории, или укажите полный путь к ним.

2. **Для интерпретатора**:
   Интерпретатор запускается из командной строки с передачей трех аргументов:

   - output.bin — путь к файлу с бинарным кодом, который нужно интерпретировать.
   - result.csv — путь к выходному файлу в формате CSV, где будут сохранены значения из диапазона памяти УВМ.
   - <start_address> <end_address> — диапазон памяти УВМ, указывающий начальный и конечный адреса, из которых интерпретатор будет считывать и сохранять значения.

   Пример запуска:   
   ```
   python interpreter.py output.bin result.csv 0 10
   ```
   Убедитесь, что все файлы находятся в той же директории, или укажите полный путь к ним.

3. **Запуск тестов**:
   ```
   pytest -v tests.py  
   ```
   
   ### Результаты тестирования
   ![image](https://github.com/user-attachments/assets/65dcb3fa-e5fb-4ba4-b45d-1e377ab96fa8)

## Реализация ассемблера
Ассемблер обрабатывает команды, проверяет их на допустимость, формирует машинные инструкции и записывает результат в удобочитаемом формате в файл log.csv.

Для удобства проверки шестнадцатеричных кодов в файле log.csv они были добавлены после каждой пары ключ=значение.
Пример содержимого файла log.csv:
```
A = 30, B = 684 (0x9E, 0x55, 0x00)
A = 0, B = 327 (0xE0, 0x28, 0x00)
A = 30, B = 690 (0x5E, 0x56, 0x00)
A = 8, B = 168 (0x08, 0x15, 0x00)
A = 30, B = 1000 (0x1E, 0x7D, 0x00)
A = 8, B = 679 (0xE8, 0x54, 0x00)
A = 30, B = 500 (0x9E, 0x3E, 0x00)
A = 20, B = 679 (0xF4, 0x54, 0x00)
```
Так же проверка корректности составления шестнадцатеричных кодов представлена в файле ``tests.py``  функции ``test_hex_code_formatting``.

### Основные функции assembler.py:
- ``format_byte(byte)`` - Форматирует байт (число) в шестнадцатеричную строку с префиксом '0x' и двухсимвольным представлением.
- ``load_constant(b)`` - Генерирует машинный код для команды LOAD_CONSTANT. Функция struct.pack упаковывает два полученных результата в байтовую строку длиной 3 байта.  
Первый байт будет содержать 8 младших битов результата операции (a | (b << 5)) & 0xFF, второй байт будет содержать 8 следующих младших битов, а третий байт - 8 старших битов.

- ``memory_read(b)`` - Генерирует машинный код для команды MEMORY_READ.
- ``memory_write(b)`` - Генерирует машинный код для команды MEMORY_WRITE.
- ``greater_than(b)`` - Генерирует машинный код для команды GREATER_THAN.
- ``assemble(input_file, output_file, log_file)`` - Основная функция ассемблера. 

Выполняет следующие задачи:

- Открывает входной файл с командами, выходной бинарный файл и лог-файл.
- Читает команды построчно, проверяет корректность и допустимость каждой команды.
- Формирует машинный код, записывает его в бинарный файл и логирует значения A и B, шестнадцатиричные коды.
- Выводит сообщения об ошибках в случае некорректных команд или значений.


## Реализация интерпретатора

Интерпретатор обрабатывает команды, выполняет их, обновляет память и выводит значения на заданных адресах памяти.

### Основные функции interpreter.py:
- ``interpret(binary_file, result_file, start, end)`` - Основная функция интерпретатора.
Выполняет следующие задачи:
- Открывает бинарный файл с командами и CSV-файл для записи результатов.
- Читает команды по 3 байта и интерпретирует их, выполняя соответствующие действия в зависимости от значения команды.
- Команды:
   - LOAD_CONSTANT (a = 30): Загружает значение b в аккумулятор.
   - MEMORY_READ (a = 0): Считывает значение из памяти по адресу b и сохраняет его в аккумуляторе.
   - MEMORY_WRITE (a = 8): Записывает значение из аккумулятора в память по адресу b.
   - GREATER_THAN (a = 20): Сравнивает значение в аккумуляторе с значением по адресу b в памяти. Если значение по адресу b больше, записывает 1 в память, иначе 0.
-По завершении обработки команд записывает в CSV-файл значения из диапазона адресов [start, end], указанных в аргументах.

